# 2d-platformer
Practice project: 2d platformer with player controls. Uses Javascript ES5 and Canvas.

Von Simmons, January 2019

Controls (Arrow keys): Left, Right, Up (Jump)

This one was quite a challenge. In my initial attempt I didn't really think through how to implement gravity. What (I thought) started as an easy obstacle snowballed into a much harder series of concepts. Gravity required me to not only check the boundaries of the Canvas, but also when the player object "landed" on another object - otherwise known as collision detection. It also presented issues with movement controls. What can a player do when they are "falling"? When can they jump again after ceasing to fall? What happens if they try to change directions when they are airborne? 

This whole spiderweb of questions and problems would have been better resolved by writing them out conceptually first. Instead I kept it all in my head and that is the last time I make that mistake. Programming works much better when you write things out with pen and paper first. Nevertheless, I managed to get this to work in an acceptable-enough form to demonstrate the idea.

So the major challenge to determining collision detection was to check the boundaries of each object next to every other object. (This has to be calculated because every object is randomly placed on the canvas on refresh) Once I started to dig into this I realized just how insane of a requirement that would be on processing. The immediate idea is to compare every pixel on the Canvas for every object, but it is simply not feasible. After researching for a few days I found out about Quadtrees. Essentially the observable area is divided into quadrants and added to a tree. Then each quadrant is checked for an object. If that quadrant has more objects than the allowable threshold then it is recursively divided and checked again. This way you only need to check all of the pixels on the Canvas ONE time and then just refer to the Quadtree after that. Only nodes that have more than 1 leaf (object) need to be checked for collision, lessening the amount of checks further.

My problem came when I went to implement movement animations. As it stands, my code runs its collision detection algorithm at every present frame. When the player object moves, the collision detection doesn't check where the object WILL be, it checks where it IS. This causes problems where the player can warp into other objects depending on how fast it is moving. If I were to do this again I would incorporate a mechanism to calculate how fast the player is moving and where it wants to go next.

I should mention that the movement uses easing-in and out. This means that when you press left or right it will start slowly and then pick up speed (up to a terminal speed). Then, when you release, the object slows down gradually from the speed it was moving. Also, the jumping and falling mechanics work in a similar way to mimic what you would expect. Problems with collision detection and when to initiate gravity on the player object causes it to "bump its head" and suddenly fall. It works almost the way I would intend, but I can't fine tune this because of how I have implemented collision detection.

This was a good challenge to try. Some things I would like to experiment with in the future are animating sprites based on several player inputs (button presses/holds/releases, where the object is on the canvas, etc.) Ultimately I chose to abandon this because of my failure to implement collision detection with player movement in the right way. The number one takeaway is to design the project with pen and paper before diving in. No matter how well I can track different ideas in my head, it will never be superior to looking at it on paper.
